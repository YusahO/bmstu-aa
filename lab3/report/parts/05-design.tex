\chapter{Конструкторская часть}

В данном разделе будут приведены псевдокоды алгоритмов блинной, быстрой и гномьей сортировок, оценки их трудоемкостей.

\section{Требования к ПО}

К программе предъявлен ряд требований:

\begin{itemize}
    \item на вход программе подается два массива;
    \item результатом сортировки является массив, выводимый на экран;
    \item программа должна позволять производить измерения процессорного времени, затрачиваемого на выполнение реализуемых алгоритмов.
\end{itemize}

\section{Разработка алгоритмов}

\begin{algorithm}[H]
    \caption{Вспомогательная функция Flip}
    \label{alg:pancake-sort-flip}
    \begin{algorithmic}[1]
        \Procedure{Flip}{$arr$, $maxNumPos$, $n$}
        \State $i\gets maxNumPos$
        \While{$i < n$}
        \State $swap\gets arr[i]$
        \State $arr[i]\gets arr[n]$
        \State $arr[n]\gets swap$
        \State $n\gets n - 1$
        \State $i\gets i + 1$
        \EndWhile
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
    \caption{Алгоритм блинной сортировки}
    \label{alg:pancake-sort}
    \text{\textbf{Вход}: ссылка на массив $arr$ размером $n$}\\
    \text{\textbf{Выход}: отсортированный массив $arr$}

    \begin{algorithmic}[1]
        \Procedure{PancakeSort}{$arr$, $n$}
        \If{$n \ge 2$}
        \State $i\gets n$
        \While{$i > 1$}
        \State $maxNumPos\gets 0$
        \For{$a\gets 0, i$}
        \If{$arr[i] > arr[maxNumPos]$}
        \State $maxNumPos\gets a$
        \EndIf
        \EndFor
        \If{$maxNumPos\ne (i - 1)$ \textbf{and} $maxNumPos\ge 0$}
        \State \Call{Flip}{$arr, maxNumPos, i$}
        \EndIf
        \EndWhile
        \EndIf
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
    \caption{Алгоритм быстрой сортировки}
    \label{alg:q-sort}
    \text{\textbf{Вход}: ссылка на массив $arr$ индексы $st$ и $end$}\\
    \text{\textbf{Выход}: отсортированный массив $arr$}

    \begin{algorithmic}[1]
        \Procedure{QSort}{$arr$, $st$, $end$}
        \State $l\gets st$
        \State $r\gets end$
        \State $piv\gets arr[\frac{l + r}{2}]$
        \While{$l\le r$}
            \While{$arr[l] < piv$}
                \State $l\gets l + 1$
            \EndWhile
            \While{$arr[l] < piv$}
                \State $r\gets r - 1$
            \EndWhile
            \If{$l\le r$}
                \State $swap\gets arr[l]$
                \State $arr[l]\gets arr[r]$
                \State $arr[r]\gets swap$
                \State $l\gets l + 1$
                \State $r\gets r - 1$
            \EndIf
        \EndWhile
        \If{$st < r$}
            \State \Call{QSort}{$arr, st, r$}
        \EndIf
        \If{$end > l$}
            \State \Call{QSort}{$arr, l, end$}
        \EndIf
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
    \caption{Алгоритм гномьей сортировки}
    \label{alg:gnome-sort}
    \text{\textbf{Вход}: ссылка на массив $arr$ размером $n$}\\
    \text{\textbf{Выход}: отсортированный массив $arr$}

    \begin{algorithmic}[1]
        \Procedure{GnomeSort}{$arr$, $n$}
        \State $i\gets 1$
        \State $j\gets 2$
        \While{$i < n$}
            \If{$arr[i - 1] < arr[i]$}
                \State $i\gets j$
                \State $j\gets j + 1$
            \Else
                \State $swap\gets arr[i - 1]$
                \State $arr[i - 1]\gets arr[i]$
                \State $arr[i]\gets swap$
                \State $i\gets i - 1$
                \If{$i == 0$}
                    \State $i\gets j$
                    \State $j\gets j + 1$
                \EndIf
            \EndIf
        \EndWhile
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\section{Описание используемых типов данных}

При реализации алгоритмов будут использованы следующие типы данных:
\begin{itemize}
    \item \textit{массив}~--- динамический массив значений типа \texttt{int}.
\end{itemize}

\section{Модель вычисления для проведения оценки трудоемкости}

Введем модель вычислений, которая потребуется для определения трудоемкости каждого отдельного взятого алгоритма умножения матриц.
\begin{enumerate}
    \item Трудоемкость базовых операций имеет:
    \begin{itemize}
        \item значение 1 для операций:
        \begin{equation}
            \begin{gathered}
                +, -, =, +=, -=, ==, !=, <, >, <=, >=, \\ 
                \text{[]}, ++, --, \&\&, ||, >>, <<, \&, |
            \end{gathered}
        \end{equation}
        \item значение 2 для операций:
        \begin{equation}
            *, /, \%, *=, /=, \%=.
        \end{equation}
    \end{itemize}
    \item Трудоемкость условного оператора:
    \begin{equation}
        f_{\text{if}} =
        \begin{cases}
            \min({f_1, f_2}), & \text{лучший случай} \\
            \max({f_1, f_2}), & \text{худший случай}.
        \end{cases}
    \end{equation}
    \item Трудоемкость цикла
    \begin{equation}
        \begin{gathered}
            f_{\text{for}} = f_{\text{инициализация}} + f_{\text{сравнение}} + \\
            + M_{\text{итераций}} \cdot (f_{\text{тело}} + f_{\text{инкремент}} + f_{\text{сравнение}}).
        \end{gathered} 
    \end{equation}
    \item Трудоемкость передачи параметра в функцию и возврат из нее равен 0.
\end{enumerate}

\section{Трудоемкость алгоритмов}

Ниже приведены оценки трудоемкостей алгоритмов блинной, быстрой и гномьей сортировок.

Пусть требуется отсортировать массив $A$ размером $N$.

\section{Блинная сортировка}

Трудоемкость блинной сортировки складывается из:
\begin{itemize}
    \item трудоемкости проверки вырожденного случая, равной 1;
    \item трудоемкости цикла сортировки:
    \begin{equation}
        f_{PanSort} = 2 + N \cdot (2 + f_{FindMax} + f_{Flip}),
    \end{equation}
    \item трудоемкости поиска позиции максимального элемента в подмассиве $A[0..i]$, $i = \overline{1, N}$
    \begin{equation}
        \begin{gathered}
            f_{FindMax} = 3 + \\ + M \cdot \left ( 2 +
            \begin{cases}
                1, & \text{$j$-й элемент больше максимального}\\
                0, & \text{иначе}\\
            \end{cases} \right ),
        \end{gathered}
    \end{equation}
    где $M$~--- размер подмассива $A[1..i]$;
    \item трудоемкости отражения элементов массива
    \begin{equation}
        f_{Flip} = 
        \begin{cases}
            2, & \text{макс. элемент последний в }A[0..i]\\
            f_{FlipLoop}, & \text{иначе},
        \end{cases}
    \end{equation}
    где $f_{FlipLoop}$~--- трудоемкость цикла обмена элементами массива при его отражении;
    \begin{equation}
        f_{FlipLoop} = 2 + \frac{L}{2} \cdot (2 + 3 + 2),
    \end{equation}
    где $L$~--- количество элементов в массиве между максимальным в подмассиве $A[0..i]$ и $i$-м.
\end{itemize}

Таким образом, трудоемкость блинной сортировки равна
\begin{equation}
    \begin{gathered}
        F_{PanSort} = 2 + 7N + 3MN + \frac{7NL}{2} \approx O(N^2)
    \end{gathered}
\end{equation}

\section{Быстрая сортировка}

Трудоемкость быстрой сортировки складывается из:
\begin{equation}
    \begin{gathered}
        f_{QSort} = 7 + 1 \cdot N \cdot (2 + \frac{N}{2} + 2 + \frac{N}{2} + 1 + 9)
    \end{gathered}
\end{equation}

\section{Гномья сортировка}

Трудоемкость гномьей сортировки складывается из:
\begin{itemize}
    \item трудоемкости начальной инициализации переменных: $2$;
    \item трудоемкости цикла сортировки:
    \begin{equation}
        f_{GnomeSort} = N \cdot (1 + f_{Branch}),
    \end{equation}
    \item трудоемкости обработки случая, когда обнаружен элемент, нарушающий порядок
    \begin{equation}
        f_{Branch} = 3 + 
        \begin{cases}
            2, & \text{$i$-й элемент < $i$-го}\\
            5 + 3 + 2 + 2, & \text{иначе}
        \end{cases}
    \end{equation}
\end{itemize}

Таким образом, трудоемкость гномьей сортировки равна
\begin{equation}
    f_{GnomeSort} = 13N.
\end{equation}
На неупорядоченных данных алгоритм имеет асимптотическую сложность $O(n^2)$, а на данных, близких к упорядоченным~--- $O(n)$~\cite{gnome-complexity}.

\section*{Вывод}
\addcontentsline{toc}{section}{Вывод}